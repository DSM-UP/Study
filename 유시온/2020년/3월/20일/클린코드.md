# 클린코드



## 2020-03-11 ~ 



## 차례

1. [**깨끗한 코드**](#1깨끗한-코드)
   * 코드가 존재하리라
   * 나쁜 코드
   * 나쁜 코드로 치르는 대가
   * 우리들 생각
   * 우리는 저자다
   * 보이스카우트 규칙
   * 프리퀄과 원칙
   * 결론
2. [**의미 있는 이름**](#2의미-있는-이름)
   * 의도를 분명히 밝혀라
   * 그릇된 정보를 피하라
   * 의미 있게 구분하라
   * 발음하기 쉬운 이름을 사용하라
   * 검색하기 쉬운 이름을 사용하라
   * 인코딩을 피하라
   * 자신의 기억력을 자랑하지 마라
   * 클래스 이름
   * 메서드 이름
   * 기발한 이름은 피하라
   * 한 개념에 한 단어를 사용하라
   * 말장난을 하지 마라
   * 해법 영역에서 가져온 이름을 사용하라
   * 문제 영역에서 가져온 이름을 사용하라
   * 의미 있는 맥락을 추가하라
   * 불필요한 맥락을 없애라
3. [**함수**](#3함수)
   * 작게 만들어라!
   * 한 가지만 해라!
   * 함수 당 추상화 수준은 하나로!
   * Switch 문
   * 서술적인 이름을 사용하라!
   * 함수 인수
   * 부수 효과를 일으키지 마라!
   * 명령과 조회를 분리하라!
   * 오류 코드보다 예외를 사용하라!
   * 반복하지 마라!
   * 구조적 프로그래밍
   * 함수를 어떻게 짜죠?
4. [**주석**](#4주석)
    * 주석은 나쁜 코드를 보완하지 못한다
    * 코드로 의도를 표현하라!
    * 좋은 주석
    * 나쁜 주석
5. [**형식 맞추기**](#5형식-맞추기)
    * 형식을 맞추는 목적
    * 적절한 행 길이를 유짛라
    * 가로 형식 맞추기
    * 팀 규칙
    * 밥 아저씨의 형식 규칙
6. **객체와 자료 구조**
   * 자료 추상화
   * 자료/객체 비대칭
   * 디미터 법칙
   * 자료 전달 객체
7. **오류 처리**
    * 오류 코드보다 예외를 사용하라
    * Try-Catch-Finally 문부터 작성하라
    * 미확인 예외를 사용하라
    * 예외에 의미를 제공하라
    * 호출자를 고려해 예외 클래스를 정의하라
    * 정상 흐름을 정의하라
    * null을 반환하지 마라
    * null을 전달하지 마라
8. **경계**
   * 외부 코드 사용하기
   * 경계 살피고 익히기
   * log4j 익히기
   * 학습 테스트는 공짜 이상이다
   * 아직 존재하지 않는 코드를 사용하기
   * 깨끗한 경계
9. **단위 테스트**
   * TDD 법칙 세 가지
   * 깨끗한 테스트 코드 유짛기
   * 깨끗한 테스트 코드
   * 테스트 당 assert 하나
   * F.I.R.S.T.
10. **클래스**
    * 클래스 체계
    * 클래스는 작아야 한다!
    * 변경하기 쉬운 클래스



## 1.깨끗한 코드

* 좋은 코드는 아주 중요하며, 우리 분야에서 가장 든든하며 지지받고, 강조되어 온 전제 중 하나이다. 
* 실례로, 나쁜 코드로 인해 회사에 큰 피해를 보는 경우도 있었다.
* ***르블랑의 법칙* : 나중은 결코 오지 않는다.**
* 아무리 시간이 급하다 하여도 **나쁜 코드를 짜는 것은 프로그래머 답지 못한 행동이다.**
* 깨끗한 코드를 작성하기 위해서는 **코드 감각**이 필요하다.
* *비야네* : 깨끗한 코드는 **보기에 즐거운** 긋코드이다. **효율**이 중요하며, **철저한 오류 처리**도 중요하다. 깨끗한 코드는 **한 가지를 잘 한다.** 개
* *그래디 부치* : 깨끗한 코드는 **단순하고 직접적**이고, **명쾌한 추상화와 단순한 제어문**으로 가득하다.
* *큰 데이브 토마스* : 깨끗한 코드는 **작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.** 특정 목적을 달성하는 방법은 하나이다. 
* *마이클 페더스* : 깨끗한 코드는 **주의 깊게 작성한 코드**이다. 
* *론 제프리스* : 깨끗한 코드는 **중복이 없고, 클래스, 메소드, 함수 등을 최대한 줄인다**.
* SRP : 클래스에는 한 가지의 변경 이유만 존재해야 한다.
* OCP : 클래스는 확장에 열려 있어야 하며, 변경에 닫혀 있어야 한다.
* LSP : 상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다.
* DIP : 추상화에 의존해야 하며, 구체화에 의존하면 안된다.
* ISP : 클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다.



음, 코드 짤 때 생각 없이 짜는 내가 이 책을 본 후에는 뭔가 느끼는게 생기면 좋겠다. 아니면 코드를 정말 **깨끗이** 짜던가.



## 2.의미 있는 이름

* **의도를 분명히 밝혀라** 
  * 의도가 분명하지 않은 변수나 함수 그리고 클래스 이름은 그것의 기능과 사용법을 쉽게 파악할 수 없다. 그러한 코드는 주석을 포함해야 할 것이고. 시간 낭비도 굉장히 심할 것이다.
* **그릇된 정보를 피하라**
  * 다른 사람이 잘못되게 파악할 소지가 있는. 일관성이 떨어지는 표기법을 피해야 한다.
* **의미 있게 구분하라**
  * 확실히 구분되는 단어를 사용하지 말아야 한다. `getStudent(), getStudents(), getStudentInfo()` 
* **발음하기 쉬운 이름을 사용하라**
  * 발음하기 쉬운 이름은 협업을 할 때 아주 유용할 것이다.
* **검색하기 쉬운 이름을 사용하라**
  * 이름 길이는 범위 크기에 비례해야 한다.
* **자신의 기억력을 자랑하지 마라**
  * 이름을 지을 때에 직관적이지 못한 이름으로는 지으면 안된다.
* **클래스 이름**
  * 클래스 이름과 객체 이름은 명사나 명사구가 적합하다. 이때 많이 사용되는 단어는 피하고 동사도 사용하지 않는다. `Manager, Data, Info, Table 등`
* **메서드 이름**
  * 메서드 이름은 동사나 동사구가 적합하다. 접근자, 변경자, 조건자는 get, set, is를 붙이는 것이 좋다.
* **기발한 이름은 피하라**
  * 기발한 이름은 기억력이 요구되는 행위이므로 피해야 한다.
* **한 개념에 한 단어를 사용하라**
  * 추상적 개념에 단어를 하나만 선택해서 사용해야 한다. 뜻이 비슷한 여러 단어를 사용할 경우, 혼란을 야기할 수 있다.
* **의미 있는 맥락을 추가하라**
  * 특정 맥락을 추가하여 뜻을 파악하기 쉽게 해야 한다.
* **불필요한 맥락을 없애라**
  * 일반적으로는 짧은 이름이 긴 이름보다 좋다. 그러나 의미가 분명한 경우에 한해서이다. 



내 코드의 변수를 보게 되었다. `default-menu-modal-header` 음... 생각보다 나쁘지 않은것 같긴 한데. 확실히 의도 자체는 정확히 전달된 것 같다. JS 코드는 보기 무섭다... ㅋㅋ



## 3.함수

* **작게 만들어라!** 
  * 함수는 작게 만들수록 좋다. `if 문 / else 문 / while 문` 등에 들어가는 블록은 한줄이어야 한다.
* **한 가지만 해라!**
  * 함수는 오직 한 가지만 잘 수행 해야 한다. 
* **함수 당 추상화 수준은 하나로!**
  * 함수가 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
* **Switch 문**
  * switch 문은 작게 만들기는 어렵다. 그러니 최대한 지양하자.
* **서술적인 이름을 사용하라!**
  * 서술적인 이름의 함수는 함수의 기능을 표현하기 효율적이다.
* **함수 인수**
  * 함수의 인수는 적을 수록 좋다. 인수가 많을 수록 함수가 복잡해 지고, 기능을 파악하기 어렵다.
* **부수 효과를 일으키지 마라!**
  * 이는 함수당 한 가지 일을 수행하라는 것과 같은 뜻이다. 이는 시간적 결합과 순서 종속성을 초래한다.
* **명령과 조회를 분리하라!**
  * 함수는 뭔가를 수행하거나, 뭔가에 답하거나 둘 중 하나만 해야 한다.
* **오류 코드보다 예외를 사용하라!**
  * 오류 코드를 반환하는 방식은 여러 단계로 중첩되는 코드를 야기한다.
* **반복하지 마라!**
  * 중복을 제거하는 것이야 말로, 함수의 사용 이유일 것이다.
* **구조적 프로그래밍**
  * 함수의 크기가 커진다면 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다.



함수를 잘 짜는 것이야 말로, 프로그래머로써 뭔가 뿌듯한? 그런 상황일 것이다. 물론 내 함수는 아주 거대하고.. 반복되는... ㅎㅎ;; 음 그냥 이거 보면서 짜야할까?



## 4.주석

* **주석은 나쁜 코드를 보완하지 못한다**
  * 코드에 주석을 추가하는 일반적 이유는 코드 품질이 나쁘기 때문이다. 
* **코드를 의도로 표현하라!**
  * 코드만으로 의도를 설명하기 어려운 경우가 존재하지만, 코드로 의도를 표현하는 것이 좋다.
* **좋은 주석**
  * 어떤 주석은 필요하거나 유익하다. 회사 법적 주석이나 앞으로의 할 일을 주석으로 남기기 등은 필요하기도 하다.
    * 법적인 주석 : 회사가 정립한 표준에 맞춰 주석을 넣는 경우
    * 정보 제공 주석 : 기본적 정보를 제공하는 경우
    * 의도 설명 주석 : 구현의 의도를 설명해야 하는 경우
    * 의미 밝히는 주석 : 의미를 정확하게 밝혀야 하는 경우
    * 결과 경고 주석 : 다른 프로그래머에게 결과를 경고하는 경우
    * 중요성 강조 주석 : 중요성을 강조하는 경우
* **나쁜 주석**
  * 대다수의 주석이 이 범주에 속한다. 대다수의 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하는 경우의 독백에 불과하다.
    * 주절거리는 주석 : 특별한 이유 없이 쓰는 주석은 굉장한 시간낭비에 불과하다.
    * 중복 주석 : 이런 주석은 코드보다 정보를 제공하지 못하게 된다.
    * 오해할 여지가 있는 주석 : 의도는 좋았으나 엄밀하지 못한 주석은 오해할 여지가 생기게 된다.
    * 이력을 기록하는 주석 : 모듈 변경은 관리 시스템에 의하여 기록하는 것이 바람직하다.
    * 닫는 괄호의 주석 : 작고 캡슐화가 되있는 함수에는 잡음이 될 뿐이다.





## 5.형식 맞추기

* **형식을 맞추는 목적**