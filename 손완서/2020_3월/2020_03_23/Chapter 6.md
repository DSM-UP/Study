# Chapter 6. 익스프레스 웹 서버 만들기

## 6.1 Express-generator로 빠르게 설치하기

프레임워크에 필요한 package.json을 만들어주고 기본 폴더 구조까지 잡아주는 패키지가 바로 Express-generator입니다.

app.js 파일이 핵심적인 서버 역할을 합니다.
bin 폴더의 www파일은 서버를 실행하는 스크립트입니다.
public 폴더는 외부(브라우저 등의 클라이언트)에서 접근 가능한 파일들을 모아둔 곳입니다.
routes 폴더는 주소별 라우터들을 모아둔 곳이고, views 폴더는 템플릿 파일을 모아둔 곳입니다.

## 6.2 익스프레스 구조 이해하기

익스프레스는 코드가 여러 개의 파일로 분산되어 있습니다.
각 부분마다 맡은 역할이 나누어져 있어 보기에도 좋고, 관리하기도 좋습니다.

bin/www 파일은 http 모듈에 express 모듈을 연결하고, 포트를 지정하는 부분입니다.

## 6.3 미들웨어

미들웨어는 요청과 응답의 중간(middle, 미들)에 위치하여 미들웨어라 부릅니다.
미들웨어는 요청과 응답을 조작하여 기능을 추가하기도 하고, 나쁜 요청을 걸러내기도 합니다.

미들웨어는 주로 app.use와 함께 사용됩니다.

app.use 메서드의 인자로 들어 있는 함수가 미들웨어입니다.
미들웨어는 use 메서드로 app에 장착합니다.
제일 위의 logger('dev')부터 시작하여 미들웨어들을 순차적으로 거친 후 라우터에서 클라이언트로 응답을 보냅니다.

라우터와 에러 핸들러도 미들웨어의 일종입니다.

### 6.3.1 커스텀 미들웨어 만들기

서버가 받은 요청은 미들웨어를 타고 라우터까지 전달됩니다.

반드시 미들웨어 안에서 next()를 호출해야 다음 미들웨어로 넘어갑니다.
next()는 미들웨어의 흐름을 제어하는 핵심적인 함수입니다.

next 함수에 인자를 아무것도 넣지 않으면 단순하게 다음 미들웨어로 넘어갑니다.
next 함수의 인자로 route를 넣으면 특수한 기능을 합니다.
route 외의 다른 값을 넣으면 다른 미들웨어나 라우터를 건너 뛰고 바로 에러 핸들러로 이동합니다.
넣어준 값은 에러에 대한 내용으로 간주됩니다.

에러 핸들링 미들웨어는 일반적으로 미들웨어 중 제일 아래에 위치하여 위에 있는 미들웨어에서 발생하는 에러를 받아서 처리합니다.

### 6.3.2 morgan

요청에 대한 정보를 콘솔에 기록해줍니다.

함수의 인자로 dev 대신 short, common, combined 등을 줄 수 있습니다.
인자에 따라 콘솔에 나오는 로그가 다릅니다.

### 6.3.3 body-parser

요청의 본문을 해석해주는 미들웨어입니다.

body-parser는 JSON과 URL-encoded 형식의 본문 외에도 Raw, Text 형식의 본문을 추가로 해석할 수 있습니다.

Raw는 본문이 버퍼 데이터일 때, Text는 본문이 텍스트 데이터일 때 해석하는 미들웨어입니다.

JSON은 JSON 형식의 데이터 전달 방식이고, URL-encoded는 주소 형식으로 데이터를 보내는 방식입니다.
보통 폼 전송이 URL-encoded 방식을 주로 사용합니다.

body-parser 패키지는 내부적으로 본문을 해석해 req.body에 추가해줍니다.

### 6.3.4 cookie-parser

cookie-parser는 요청에 동봉된 쿠키를 해석해줍니다.

해석된 쿠키들은 req.cookies 객체에 들어갑니다.

첫 번째 인자로 문자열을 넣어줄 수 있습니다.
쿠키들은 제공한 문자열로 서명된 쿠키가 됩니다.
서명된 쿠키는 클라이언트에서 수정했을 때 에러가 발생하므로 클라이언트에서 쿠키로 위험한 행동을 하는 것을 방지할 수 있습니다.

### 6.3.5 static

static 미들웨어는 정적인 파일들을 제공합니다.

함수의 인자로 정적 파일들이 담겨 있는 폴더를 지정하면 됩니다.

정적 파일을 제공할 주소를 지정할 수도 있습니다.

static 미들웨어는 요청에 부합하는 정적 파일을 발견한 경우 응답으로 해당 파일을 전송합니다.
이 경우 응답을 보냈으므로 다음에 나오는 라우터가 실행되지 않습니다.

자체적으로 정적 파일 라우터 기능을 수행하므로 최대한 위쪽에 배치하는 것이 좋습니다.
그래야 서버가 쓸데없는 미들웨어 작업을 하는 것도 막을 수 있습니다.

### 6.3.6 express-session

세션 관리용 미들웨어입니다.

express-session은 인자로 세션에 대한 설정을 받습니다.
resave는 요청이 왔을 때 세션에 수정사항이 생기지 않더라도 세션을 다시 저장할지에 대한 설정이고, saveUninitialized는 세션에 저장할 내역이 없더라도 세션에 저장할지에 대한 설정입니다.
secret은 필수 항목으로 cookie-parser의 비밀키와 같은 역할을 합니다.

express-session은 세션 관리 시 클라이언트에 쿠키를 보냅니다.
이를 세션 쿠키라고 부릅니다.
안전하게 쿠키를 전송하려면 쿠키에 서명을 추가해야 하고, 쿠키를 서명하는 데 secret의 값이 필요합니다.

cookie 옵션은 세션 쿠키에 대한 설정입니다.
일반적인 쿠키 옵션이 모두 제공됩니다.

express-session은 req 객체 안에 req.session 객체를 만듭니다.
이 객체에 값을 대입하거나 삭제해서 세션을 변경할 수 있습니다.
나중에 세션을 한번에 삭제하려면 req.session.destroy() 메서드를 호출하면 됩니다.
현재 세션의 아이디는 req.sessionID로 확인할 수 있습니다.

### 6.3.7 connect-flash

connect-flash 미들웨어는 cookie-parser와 express-session을 사용하므로 이들보다는 뒤에 위치해야 합니다.

flash 미들웨어는 req 객체에 req.flash 메서드를 추가합니다.
req.flash(키, 값)으로 해당 키에 값을 설정하고, req.flash(키)로 해당 키에 대한 값을 불러옵니다.

## 6.4 Router 객체로 라우팅 분리하기

익스프레스를 사용하는 이유 중 하나가 바로 라우팅을 깔끔하게 관리할 수 있다는 점 때문입니다.

익스프레스 앱과는 app.use('/', indexRouter)와 app.use('/users', usersRouter)로 연결되어 있습니다.
라우팅 미들웨어는 첫 번째 인자로 주소를 받아서 특정 주소에 해당하는 요청이 왔을 때만 미들웨어가 동작하게 할 수도 있습니다.

use 대신 get, post, put, patch, delete 같은 HTTP 메서드를 사용할 수도 있습니다.

use 메서드는 모든 HTTP 메서드에 대해 요청 주소만 일치하면 실행되지만 get, post, put, patch, delete 같은 메서드는 주소뿐만 아니라 HTTP 메서드까지 일치하는 요청일 때만 실행됩니다.

router 객체는 express.Router()로 만들었습니다.

router 하나에 미들웨어를 여러 개 장착할 수도 있습니다.

res.render 메서드로 클라이언트에 응답을 보냅니다.

라우터에서는 반드시 요청에 대한 응답을 보내거나 에러 핸들러로 요청을 넘겨야 합니다.
응답을 보내지 않으면 브라우저는 계속 응답을 기다립니다.

라우터 주소에는 특수한 패턴을 사용할 수 있습니다.

주소에 :id 부분에는 다른 값을 넣을 수 있습니다.
이 방식의 장점은 :id에 해당하는 1이나 123을 조회할 수 있다는 점입니다.

주소에 쿼리스트링을 쓸 때도 있습니다.

send는 만등 메서드입니다.
버퍼 데이터나 문자열을 전송하거나, HTML 코드를 전송하기도 하고, JSON 데이터도 전송할 수 있습니다.
sendFile은 파일을 응답으로 보내주는 메서드고, json은 JSON 데이터를 보내줍니다.
redirect는 응답을 다른 라우터로 보내 버립니다.

render 메서드는 템플릿 엔진을 렌더링할 때 사용합니다.

## 6.5 템플릿 엔진 사용하기

HTML은 정적인 언어입니다.

템플릿 엔진은 자바스크립트를 사용해서 HTML을 렌더링할 수 있게 해줍니다.

### 6.5.1 Pug(Jade)

예전 이름인 Jade로 더 유명한 Pug는 문법이 간단하여 코드의 양이 줄어들기 때문에 인기가 있습니다.

views는 템플릿 파일들이 위치한 폴더를 지정하는 것입니다.
res.render 메서드가 이 폴더 기준으로 템플릿 엔진을 찾아서 렌더링합니다.

view engine은 어떠한 종류의 템플릿 엔진을 사용할지를 나타냅니다.

#### 6.5.1.1 HTML 표현

기존 HTML과 다르게 화살괄호(<>)와 닫는 태그가 없습니다.
탭 또는 스페이스로만 태그의 부모 자식 관계를 규명합니다.

태그의 속성도 태그명 뒤에 소괄호로 묶어 적어줍니다.

div 태그인 경우 div 문자는 생략할 수 있습니다.

HTML 텍스트는 태그 또는 속성 뒤에 한 칸을 띄고 입력합니다.

에디터에서 텍스트를 여러 줄 입력하고 싶다면 파이프(|)를 넣어줍니다.

style이나 script 태그로 CSS 또는 자바스크립트 코드를 작성하고 싶다면 태그 뒤에 점(.)을 붙여줍니다.

#### 6.5.1.2 변수

자바스크립트 변수를 템플릿에 렌더링할 수 있습니다.
res.render 호출 시 보내는 변수를 Pug가 처리해줍니다.

res.render(템플릿, 변수 객체)는 익스프레스가 res 객체에 추가한 템플릿 렌더링을 위한 메서드입니다.
index.pug를 HTML로 렌더링하면서 { title: 'Express' }라는 객체를 변수로 집어 넣습니다.

res.render 메서드에 두 번째 인자로 변수 객체를 넣는 대신, res.locals 객체를 사용해서 변수를 넣을 수도 있습니다.

서버로부터 받은 변수는 다양한 방식으로 Pug에서 사용할 수 있습니다.
변수를 텍스트로 사용하고 싶다면 태그 뒤에 =를 붙인 후 변수를 입력합니다.
텍스트 중간에 변수를 넣으려면 #{변수}를 사용하면 됩니다.

내부에 직접 변수를 선언할 수도 있습니다.
빼기(-)를 먼저 입력하면 뒤에 자바스크립트 구문을 작성할 수 있습니다.

Pug는 기본적으로 변수의 특수문자를 HTML 엔티티로 이스케이프합니다.
이스케이프를 원하지 않는다면 !=를 사용하면 됩니다.

#### 6.5.1.3 반복문

반복문도 사용할 수 있습니다.
each로 반복문을 돌릴 수 있습니다.
each 대신 for 를 써도 됩니다.

반복문 사용 시 인덱스도 가져올 수 있습니다.

#### 6.5.1.4 조건문

조건문으로 편리하게 분기 처리할 수 있습니다.
case 문도 가능합니다.

#### 6.5.1.5 include

웹 제작 시 공통되는 부분을 따로 관리할 수 있어 매 페이지마다 동일한 HTML을 넣어야 하는 번거로움을 없애줍니다.

#### 6.5.1.6 extends와 block

공통되는 레이아웃 부분을 따로 관리할 수 있어 좋습니다.

페이지마다 달라지는 부분을 block으로 비워둡니다.
block을 선언하는 방법은 block [블록명]입니다.

block이 되는 파일에서는 extends 키워드로 레이아웃 파일을 지정하고 block 부분을 넣어줍니다.

### 6.5.2 EJS

EJS는 Pug와 HTML 문법 변화에 적응하기 힘든 분을 위한 템플릿 엔진입니다.

#### 6.5.2.1 변수

EJS에서 변수는 <%= %>로 감쌉니다.
내부에 변수를 사용할 수도 있습니다.
자바스크립트 코드는 <% %> 안에 적어줍니다.
HTML을 이스케이프하고 싶지 않다면 <%- %>로 감싸줍니다.

#### 6.5.2.2 반복문

EJS에서는 자바스크립트 코드를 <% %> 안에 씁니다.
반복문도 이 안에 쓰면 됩니다.
for나 while 같은 반복문을 사용하면 됩니다.

#### 6.5.2.3 조건문

조건문도 <% %> 안에 씁니다.
case문도 사용 가능합니다.

#### 6.5.2.4 include

HTML 파일을 포함하려면 <%- include(파일 경로, 데이터) %>을 하면 됩니다.
EJS는 Pug의 layout과 block은 지원하지 않습니다.
head 태그 같이 중복되는 부분은 나중에 별도의 파일로 분리하여 include로 넣으면 됩니다.

### 6.5.3 에러 처리 미들웨어

에러 처리 미들웨어는 error라는 템플릿 파일을 렌더링합니다.
렌더링 시 res.locals.message와 res.locals.error에 넣어준 값을 함께 렌더링합니다.
res.render에 변수를 대입하는 것 외에도, 이렇게 res.locals 속성에 값을 대입하여 템플릿 엔진에 변수를 주입할 수 있습니다.

error 객체는 시스템 환경이 development(개발 환경)가 아닌 경우에만 표시됩니다.

코드 중에 req.app.get(키)라는 것이 있습니다.
req.app을 통해서 app 객체에 접근하는 것입니다.
app.get(키)가 app.set(키)로 설정했던 것을 가져오는 코드이므로 req.app.get(키)로도 가능합니다.
