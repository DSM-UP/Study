# git - 5일차		

**git 객체 모델과 파일에 대한 자세한 설명**

최초파일과 객체 =  작업 디렉터리에 있는 file1, file2가 있다고 할 경우 저 두 파일과 관련있는 master 브랜치에는 file1가 file2의 콘텐츠와 완전히 동일한 a, b 라는 트리를 기록하는 커밋이있다.

그리고 인덱스에는 두파일에대해 SHA1값을 각각 기록한다. 작업 디렉터리와 인덱스, 그리고 객체 저장소는 모두 동기화되어 수정된 것이없다.

만약 파일1을 편집하면 작업디렉터리만 수정된 것으로 간주한다.

git add file1 명령을 사용해서 file2를 준비 사태로 설정하지않았기 때문에 인덱스는 file2만 계속해서 blob파일을 참조하는 것을 알 수있다.

이시점에서 file1은 인덱스에 준비상태로 설정되어있고 인덱스만 수정한것으로 간주된다.



1. 인덱스 트리 객체 변환 -> 2.커미 객체 생성 -> 3. 브랜치 참조 업데이트

#### chapter6 커밋

커밋이 발생하면 인덱스의 스냅샷을 기록해서 객체 저장소에 저장한다. git 에서는 인덱스에 있는 파일의 스냅샷과 이전 스냅샷을 비교하여 영향을 받은 파일과 디렉터리 목록을 뽑아냄.

**원자적 변경 세트**

모든 커밋은 이전 상태와 관련된 원자적 변경 세트를 나타낸다. 

커밋 스내샷은 수정된 파일을 모두 포함하고 있는 세트라고 할 수 있으며, 하나의 트리 상태를 나타내야 한다.

그리고 스냅샷 간의 변화는 트리 대 트리 변화를 나타낸다. 

git에서는 파일의 변경 이유를 고려하지 않음. 즉 변경 사항의 콘텐츠는 문제가 되지 않는다.

파일을 한 위치에서 다른 위치로 이동하는 작업을 수행할 경우 단일 동작으로 처리 가능하다.

그럼에도 중요한 이유는 베스트 프랙티스에 따라 좀 더 적절하게 커밋을  구조화할수 있기 때문이다.

**커밋 식별하기**

코드를 비교하려면 두개의 커밋을 지정해야 하며, 커밋 히스토리를 편집하려면 커밋 모음을 제공해야 한다.

git에서는 명시적, 묵시적 참조를 통하여 각각의 커밋을 참조 할 수 있다.

SHA1 커밋 ID는 명시적 참조인 반면 항상 최신 커밋을 가르키는 HEAD는 묵시적 참조이다. 

**절대적 커밋 이름**

커밋과 관련하여 가장 엄격한 이름은 해시ID이다. 해시ID는 절대적인 이름이고 ,이는 정화히 하나의 커밋만을  참조 할수 있다는 것을 의미한다. 따라서 커밋이 저네 저장소 히스토리의 어디에 있는지는 문제되지않는다. 

각 커밋은 전역적으로 모든 저장소에서도 고유하다. 예를 들어 커밋ID가 있는 컴퓨터에 동일한 커밋ID를 받으면 동일한 커밋을 가지고 있다는 것을 확신 할 수 있다.

**참조와 심볼릭 참조**

참조는 Git 객체 저장소 내에 있는 객체를 참조하는 SHA1 해시 ID이다. 참조는 모든 GIt 객체를 참조할 수 있지만, 대개는 커밋 객체를 참조한다, 심볼릭 참조는 간접적으로 Git객체를 가리키는이름이며, 이 또한 참조에 해당한다.

로컬 토픽 브랜치 이름, 원격 추적 브랜치 이름 도 모두 참조이다.



심볼릭 참조는 refs/로 시작하는 명시적인 전체이름을 가지고 있으며, 저장소의 .git/refs/디렉터리 내에 계층적으로 저장된다.



로컬 브랜치용으로 refs/heads/ref , 원격 추정 브랜치용 refs/remotes/ref 및 태그에서 사용되는 refs/tags/ref라는 기본 네임스페이스가 있다.



전체참조이름이나 약식 이름중 원하는 이름을 사용할 수 있지만, 이름이 같은 브랜치, 태그가 있을경우 휴리스틱 기법을 적용하여 git rev-parse 맨페이지의 다음 목록에 따라 처음이 일치하는 항복 사용함.



HEAD = 최신 커밋 참조

ORIG_HEAD = 병합 및 재설정과 같은 특정 작업에서는 HEAD를 새값으로 조정되기 전까지 이전버전의 HEAD를 저장함.

FETCH_HEAD = 원격저장소를 사용하는 경우 git fetch 명령은 가져온 모든 브랜치의 헤드를 저장함.

마지막 브랜치의 헤드를 의미하는 약어로 패치작업 직후에만 유효함.

MERGE_HEAD = 병합 작업하면 다른 브랜치의 헤더가 심볼릭 참조 MERGE_HEAD에 임시로 기록된다.



**상대적 커밋 이름**

git에는 다른 참조를 기준으로 상대적인 위치에 있는 커밋을 식별하는 메커니즘도 있다.

master 브랜치의 끝에서 두 번째  커밋을 참조한다. master 와 master ^에서 master^는 항상 master 브렌치의 끝에서 두 번째 커밋을 참조한다.

master ^^ 나 master~2와 같은 이름을 사용할 수 있다.

첫 번째 루트 커밋을 제외한 모든 커밋 적어도 하나 이상의 이전 커밋에서 파생되어 바로 이전 커밋을 상위 커밋이라고 부른다. 상위 커밋이 여러 개인 커밋은 병합 작업의 결과이다. 

캐럿은 동일 차수 내에서 각기 다른 상위 커밋을 선택할때 사용됨

c^1은 첫번째 상위, c^2는 두번째상위, c^3은 세번째상위를 나타냄

물결표시는 상위 차수 선택할 때 사용됨, c~1은 1차 상수,c~2은 2차상위,c~3은 3차상위로 나타냄

여러 개의 1차 상위의 첫번째상위커밋등과 같은 표현을 사용할수 있다. 



이외에도 git에선 c^과 c~은 각각 c^1과 c~1의 약식표현이다. 

git show branch --more=35 | tail -10 = 마지막 10줄로 ㅈ한하는옵션으로 병합구조확인된다.



**기존 커밋 보기**

git log master



git log --pretty=short --abbrev-commit master~12..master~10 으로 범위를 제한하여볼수있다

since..until형식임.

git log -q -p 4fe864488로 커밋에 의해적용된 패치나 변경 사항을 하나 볼수있다.



**커밋 그래프**

깃에서는  DAG (방향성이 있는 비순환 그래프) 라는 특수 그래프를 사용한다. DAG에는 두 가지 중요한 속성이있다.

1. 그래프 내의 모든 에지가 한 노드에서 다른 노드로 방햐엉을 가지고 연결됨
2. 그래프 내의 임의의 한 노드에서 시작했을 때 방향성이 있는 에지를 따라 처음 시작했던 노드로 돌아올 경로가 없다는 것이다.

git log ^X Y 는 git log X..Y와 동일한 기능을 하며, 이 명령에는 X를 포함하여 X에이르는 모든 커밋을 제외하고서 Y로 도달할 수 있는 모든 커밋을 표시한다.



**gitk를 사용하여  사용하여 커밋 그래프 보기**

igtk 로하면 DAG가 뜬다. 여기서는 각 커밋은 0개 이상의상위 커밋을 가질수 있으며, 상위 커밋이없는 최초커밋, 병합커밋은 두개 이상의 상위 커밋, 일반적인 커밋은 하나의 상위 커밋만 있다는 특성이 있다.

하위 커밋이 두개 이상인 커밋은 히스토리의 분기가 시작되면서 브랜치가 만들어짐



**커밋 범위**

커밋범위는 start..end처럼 이중 마침표로 포함된다.  start로부터 도달하는것이아닌 end로 부터 도달할 수 있는 커밋을 정의하기에, end커밋 포함, start 커밋은 제외이다.





start..end

start나 end를 생략하면 생략한 자리에  HEAD가 있는 것으로 간주된다.



마지막으로 A...B는 대칭 차집합을 나타내며, 이는 A나 B로부터 도달할수있지만, 둘다로부터는 도달 못하는 커밋의 집합을 나타낸다.



A...b범위에 속하는 리비전 집합을 구하는 명령

git rev-list A B --not $(git marge-base --all A B)



#### 커밋 찾기

**git bisect 사용하기**

git bisect 명령은 임의의 검색 조건을 바탕으로 결함이 있는 특정 커밋을 분리하는 도구이다.

git bisect start를 실행하면 git은 이분검색모드로 전환됨. git 에서는 현재 체크아웃된 버전을 관리하기 위해 독립된 HEAD를 사용한다. 이 독립된 HEAD는 기본적으로 익명의 브랜치로서 다른 리비전을 가르킬수있다.



git bisect bad = 이분검색에서 나쁜커밋을 지정함

git bisect good 버전

좋은 버전, 나쁜 버전을 식별하는 과정의 진행 상황에 따라 좋은버전에서 나쁜 버전으로 전환이 발생한 커밋들의 범위가 결정됨.

그 단계마다 남아있는리비전수 표시됨



**git blame**

특정 커밋을 식별하는데 사용할 수 있는 또 하나의 도구인 git blame 명령은 파일의 각 줄은 마지막 수정한 사람, 변경사항을 알려준다.

git blame -L 35, init/version.c

**Pickaxe 사용하기**

git blame 명령은 현재 상태를 알려 주는 반면, git log -Sstring 명령은 파일의 차이점 히스토리에서 저장된 String을 검색한다. 실제 차이점을 검색하여 추가 및 삭제 작업을 수행한 커밋을 찾을 수 있다.

git log -s옵션을 지정하는것을 pickaxe라고부름.	