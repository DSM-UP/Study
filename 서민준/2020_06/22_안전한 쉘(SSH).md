# 안전한 쉘 (SSH: Secure SHell)

비교적 쉽게 구현할 수 있고 적은 비용으로 설계한 안전한 네트워크 통신용 프로토콜

원격 로그인과 X 터미널용으로 선택됨

임베디드 시스템을 제외하면 암호 기술을 사용하는 가장 널리 사용되는 응용 중 하나

## 프로토콜

![SSH 프로토콜 스택](C:\Users\user\Desktop\SSH 프로토콜 스택.JPG)

일반적으로 수행되는 3개의 프로토콜로 구성된다.

### 전송 계층 프로토콜

- 전방향 기밀(forward Secerecy)
    한 세션에서 세션 키나 영구 개인 키가 손상되더라도, 이것은 이전 세션의 기밀성에 영향을 미치지 않는다.

전방향 기밀을 만족하는 서버 인증, 데이터 기밀성, 데이터 무결성을 제공

옵션으로 압축을 할 수 있다.

#### 호스트 키

공개 키/개인 키 쌍을 소유한 서버의 전송 계층에서 서버 인증이 수행

서버는 여러 개의 서로 다른 비대칭 키 암호 알고리즘을 사용하는 여러 개의 호스트 키를 가질 수 있음

여러 호스트가 동일한 호스트 키를 공유할 수도 있음



2가지 신뢰 모델

1. client는 각 호스트 이름과 대응되는 호스트 공개 키를 짝지어 주는 local database를 가지고 있다.
    중앙 집중식 기반구조, 제 3의 조정기관 필요 없음
    이름-키 쌍 데이터베이스를 관리하기가 부담스러움
2. 호스트 이름-키 연관관계가 신뢰된 인증 기관(CA)에 의해 인증됨
    클라이언트는 오직 CA의 루트 키만 알고 있고 CA가 인증한 모든 호스트 키를 검증할 수 있음
    이상적으로 클라이언트는 하나의 CA 키만 안전하게 보관하면 되기에 관리 문제 완화 가능
    각 호스트 키는 인가(authorization) 이전에 미리 중앙기관에 의해 적절하게 인증될 수 있어야 함

#### 패킷 교환

![SSH 전송계층 프로토콜 패킷 교환](C:\Users\user\Desktop\SSH 전송계층 프로토콜 패킷 교환.JPG)

1. 클라이언트는 서버와 TCP 연결을 설정

2. 클라이언트와 서버는 패킷이라 불리는 TCP 세그먼트의 데이터 필드를 통해 데이터 교환

    - 패킷 길이 : 패킷 길이와 MAC 필드는 포함하지 않은 패킷의 바이트 길이
    - 패딩 길이 : 랜덤 패딩의 길이
    - 페이로드 : 패킷의 유용한 정보. 어떤 알고리즘을 사용할지 협상이 완료된 뒤에 압축됨.
    - 랜덤 패딩 : 암호화 알고리즘이 협상되면 이 필드를 추가함. 임의의 바이트 길이를 가진 패딩.
    - 메시지 인증 코드(MAC: Message Authentication Code) : 메시지 인증 협상이 완료되면 이 필드에 값이 채워짐.
        순서번호는 통상 32-비트 패킷, 첫 번째 패킷은 0으로 초기화하고 이후 1씩 증가함.
        순서번호는 TCP 연결을 통해 전송되는 패킷에는 포함하지 않음

3. 암호화 알고리즘 협상

    이 완료되면 MAC 값을 계산하고 MAC 필드를 제외한 전체 패킷을 암호화한다.

    1. 식별 문자열 교환 : 클라이언트가 식별자를 전송하면 서버도 자신의 식별 문자열로 응답한다.
    2. 알고리즘 협상 : 각각 지원할 수 있는 알고리즘을 선호도 순으로 정렬한 목록을 `SSH_MSG_KEXINIT`에 포함시켜 전송
        키 교환, 암호, MAC 알고리즘, 압축 알고리즘이 알고리즘에 해당
    3. 키 교환 후 `SSH_MSG_NEWKEYS`를 전송해 키 교환 종료를 알림
    4. 서비스 요청 : 클라이언트는 사용자 인증 혹은 연결 프로토콜을 요청하기 위해 `SSH_MSG_SERVICE_REQUEST`를 보낸다.
        이어 전송되는 모든 데이터는 SSH 전송 계층 패킷의 페이로드에 실어 교환하느데 암호화 및 MAC으로 보호된다.

### 사용자 인증 프로토콜

클라이언트가 서버에게 인증받는 수단을 제공

#### 메시지 유형과 방식

항상 3가지 메시지 유형이 사용된다. 클라이언트가 보내는 인증 요청 방식은 다음과 같다.

| 바이트 | SSH_MSG_USERAUTH_REQUEST (50) |
| ------ | ----------------------------- |
| 문자열 | 사용자 이름(user name)        |
| 문자열 | 서비스 이름(service name)     |
| 문자열 | 방법 이름(method name)        |
| ...... | 방법별 필드들                 |

- 사용자 이름 : 클라이언트가 주장하는 인가용 신원
- 서비스 이름 : 클라이언트가 접근하고자 하는 기능(보편적으로 SSH 프로토콜)
- 방법 이름 : 이 요청 시 사용할 인증 방법

서버가 인증 요청을 거절하거나 요청을 수락하지만 하나 이상의 인증 방법을 요구할 경우 다음과 같이 전송함

| 바이트    | SSH_MSG_USERAUTH_FULLURE (51) |
| --------- | ----------------------------- |
| 이름-목록 | 계속될 수 있는 인증들         |
| boolean   | 부분적 성공                   |

- 이름-목록 : 대화를 계속할 수 있는 방법의 목록. 서버가 인증을 수용하면 SSH_MSG_USERAUTH_SUCCESS (52)를 전송

#### 메시지 교환

1. 클라이언트는 방법 이름 문자열이 "none"인 SSH_MSG_USERAUTH_REQUEST를 전송
2. 서버는 사용자 이름이 유효한지 검사. 유효하지 않다면 부분 성공 필드값을 false로 설정해 SSH_MSG_USERAUTH를 전송
    만약 사용자 이름이 유용하면 다음 단계를 수행
3. 서버는 SSH_MSG_USERAUTH_FULLURE를 반환. 이때 사용할 하나 이상의 인증 방법 목록도 함께 반환
4. 클라이언트는 수용할 수 있는 인증 방법 중 하나 선택, 선택한 방법 이름과 그 방법에 필요한 필드와 함께 SSH_MSG_USERAUTH_REQUEST을 전송. 인증 방법 수행을 위한 일련의 교환이 있을 수 있음
5. 인증이 성공적으로 이뤄지고 다른 인증 방법을 요구하면 서버는 부분 성공 필드값을 true로 설정 후 3단계를 수행
6. 요구된 모든 인증 방법이 성공하면, 서버는 SSH_MSG_USERAUTH_SUCCESS 메시지를 송신하고 인증 프로토콜 종료

#### 인증 방법

서버는 다음 중 한 가지 이사의 인증 방법 요구

- 공개 키
- 패스워드 : 평문 패스워드가 포함된 메시지를 클라이언트가 보낸다.
- 호스틔기반 : 클라이언트 호스트가 인증을 수행

### 연결 프로토콜

하나의 기본 SSH 연결을 사용하여 여러 개의 논리적 통신 채널을 다중화

